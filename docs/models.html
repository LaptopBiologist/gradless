---

title: costs - Wrapping objective functions and data 


keywords: fastai
sidebar: home_sidebar



nb_path: "03_models.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: 03_models.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>A collection of classes and functions to structuring models to be optimized.</p>
<hr>
<p>The <a href="/gradless/optimizers.html#GradientDescent"><code>GradientDescent</code></a> optimizer expects the cost function to be stored within a class with an <code>evaluate()</code> method, which takes a 1D numpy array of parameter values and returns a float. A generic class <a href="/gradless/models.html#Model"><code>Model</code></a> is provided to organize user-defined cost functions and data so they can be easily passed to the optimizer.</p>
<p>Should this class prove insufficient in some circumstances, a description of the API expected by <a href="/gradless/optimizers.html#GradientDescent"><code>GradientDescent</code></a> along with an abstract base class is provided.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="ModelBase" class="doc_header"><code>class</code> <code>ModelBase</code><a href="https://github.com/LaptopBiologist/gradless/tree/master/gradless/costs.py#L13" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>ModelBase</code>() :: <code>ABC</code></p>
</blockquote>
<p>A helper class that provides a standard means to create
classes to store models used by GradientDescent.</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<hr>
<p>The base class <a href="/gradless/models.html#ModelBase"><code>ModelBase</code></a> is relatively simple, consisting of two methods and two attributes</p>
<p>The methods are</p>
<ol>
<li><code>.evaluate</code> which must be defined in any particular cost function class written by the user</li>
<li><code>.sample_rvs</code> which is automatically included in the base class, and draws a random variable if a random variable generator is stored in the RV attribute</li>
</ol>
<p>The two attributes are</p>
<ol>
<li><code>RV</code> which by default is <code>None</code>, but may be used to store a function that can generate random variables that are used in the evaluation of the cost function (e.g. <code>scipy.stats.norm.rvs</code>)</li>
<li><code>update_rvs</code> is a flag that tells the <a href="/gradless/gradient.html#SPSAGradient"><code>SPSAGradient</code></a> class to update the random variable each time it evaluates the gradient. By default this is <code>True</code>, though this will only have an effect if a random variable generator is included in the cost.</li>
</ol>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="Model" class="doc_header"><code>class</code> <code>Model</code><a href="https://github.com/LaptopBiologist/gradless/tree/master/gradless/costs.py#L35" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>Model</code>(<strong><code>cost</code></strong>, <strong><code>data</code></strong>=<em><code>None</code></em>, <strong><code>RV</code></strong>=<em><code>None</code></em>, <strong><code>update_rvs</code></strong>=<em><code>False</code></em>) :: <a href="/gradless/models.html#ModelBase"><code>ModelBase</code></a></p>
</blockquote>
<p>A class for passing objective functions and data to the GradientDescent
optimizer</p>
<p>Inputs:</p>
<p>cost - the objective function to be minimized
data - the data to which the model will be fit (optional)
RV - An object with a .rvs() method to generate random variables
    for the cost function
update_rvs: True/False call RV.rvs() before each gradient evaluation</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's organized this data as a dictionary</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now we need a function that takes a vector of parameter values and data and uses these to returns a float. Note that it does not matter how the data is organized, so long as the function can interpret it internally.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<hr>
<p>In general, though, it shouldn't be necessary to use the base class, as most simple cost functions can be wrapped in an instance of the <a href="/gradless/models.html#Model"><code>Model</code></a> class. The <a href="/gradless/models.html#Model"><code>Model</code></a> class can be used to wrapped both a cost function and data</p>
<p>The only required argument is a user-defined cost function. If the model is to be fit to data, then the data--organized in a way that the cost function expects--should also passed to the class.</p>
<p>The <code>cost</code> function should take three arguments:</p>
<ol>
<li><code>theta</code>: A 1-d numpy array of model parameters</li>
<li><code>data</code>: (Optional) A variable storing the data</li>
<li><code>z</code>: (Optional) The outcome of a random variable used to compute the objective function.</li>
</ol>
<p>The <code>data</code> may be organized however the <code>cost</code> expects, for example as dictionary, a list, or a numpy array.</p>
<p>The two optional arguments taken by <a href="/gradless/models.html#Model"><code>Model</code></a> relate to a random variable that may be passed to the cost function:</p>
<ol>
<li><code>RV</code> may be a passed a object with a <code>.rvs()</code> method that generates a random variable when called (e.g. a frozen scipy distribution such are <code>scipy.stats.norm([0]*10,[1]*10)</code> which can be used to generate 10 samples from a unit normal distribution.</li>
<li><code>update_rvs</code> stores a True/False value, telling the gradient approximation whether to regenerate the random variable after each gradient estimate.</li>
</ol>
<p>The current value the random variable drawn from <code>RV</code> is stored as the attribute <code>z</code>.</p>
<p>If these options are employed, the gradient approximation holds the random variable <code>z</code> constant during the forward and backward perturbations used to approximate the gradient. In general, I think it may be best to not use these options--my intution is that noise in the gradient due a simulator employed in the objective function ought to be left inside in the gradient (but I could be wrong). However, there are cases where it absolutely make sense to eliminate sources of randomness from the gradient evaluation, for example the Monte Carlo integration often employed to compute the objective function used in variational inference.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Example-usage">Example usage<a class="anchor-link" href="#Example-usage"> </a></h2><p>Okay, let's try out an example, where we are interested in the mean-squared error of a simple linear regression.</p>
<p>Now let's generate 200 data points from a simple linear relationship, with a slope of 2 and an intercept of 5:</p>
<p>{% raw %}
$$x \sim normal(0, 5)$$
{% endraw %}</p>
<p>{% raw %}
$$\epsilon \sim normal(0,2)$$
{% endraw %}</p>
<p>{% raw %}
$$y=2x+5+\epsilon$$
{% endraw %}</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">x</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
<span class="n">err</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
<span class="n">slope</span><span class="o">=</span><span class="mi">2</span>
<span class="n">intercept</span><span class="o">=</span><span class="mi">5</span>
<span class="n">y</span><span class="o">=</span><span class="n">x</span><span class="o">*</span><span class="n">slope</span><span class="o">+</span><span class="n">intercept</span> <span class="o">+</span><span class="n">err</span>
<span class="c1"># pyplot.scatter(x,y)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's organized this data as a dictionary</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span><span class="n">x</span><span class="p">,</span>
     <span class="s1">&#39;y&#39;</span><span class="p">:</span><span class="n">y</span><span class="p">}</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now we need a function that takes a vector of parameter values and data and uses these to returns a float. Note that it does not matter how the data is organized, so long as the function can interpret it internally.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">MSE</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
    <span class="n">y_pred</span><span class="o">=</span><span class="n">theta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="n">theta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">y</span><span class="o">-</span><span class="n">y_pred</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Okay, now we'll wrap the cost function and the data in the <a href="/gradless/models.html#Model"><code>Model</code></a> class</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">mse_cost</span><span class="o">=</span><span class="n">Model</span><span class="p">(</span><span class="n">MSE</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Because we didn't pass any random variable generators, both <code>update_rvs</code> and <code>RV</code> remain at their default values:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mse_cost.RV = </span><span class="si">{mse_cost.RV}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mse_cost.update_rvs = </span><span class="si">{mse_cost.update_rvs}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can evaluate the cost function on the data by passing a proposed parameter value to the <code>.evaluate()</code> method:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">mse_cost</span><span class="o">.</span><span class="n">evaluate</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We could further use this to visualize the landscape of the objective function a grid of different combinations of (slope, intercept) parameters (the parameter value used to generate the data is marked with a red X):</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="o">=</span><span class="p">[],[],[]</span>
<span class="k">for</span> <span class="n">slope</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span><span class="o">.</span><span class="mi">2</span><span class="p">):</span>

    <span class="k">for</span> <span class="n">intercept</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span><span class="o">.</span><span class="mi">2</span><span class="p">):</span>
        <span class="n">Y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">intercept</span><span class="p">)</span>
        <span class="n">X</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slope</span><span class="p">)</span>
        <span class="n">Z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mse_cost</span><span class="o">.</span><span class="n">evaluate</span><span class="p">([</span><span class="n">slope</span><span class="p">,</span><span class="n">intercept</span><span class="p">]))</span>
<span class="n">sc</span><span class="o">=</span><span class="n">pyplot</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">Z</span><span class="p">))</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="n">cbar</span><span class="o">=</span><span class="n">pyplot</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>
<span class="n">cbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">&#39;log (MSE)&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Intercept&#39;</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Slope&#39;</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
<span class="n">pyplot</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

</div>
 

