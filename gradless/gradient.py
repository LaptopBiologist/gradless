# AUTOGENERATED! DO NOT EDIT! File to edit: 04_gradient.ipynb (unless otherwise specified).

__all__ = ['SPSAGradient']

# Cell
import numpy
import scipy


# Cell
class SPSAGradient():
    def __init__(self, param_subsets=None):
        self.param_subsets=param_subsets
        if self.param_subsets is not None:
            self.param_subsets=numpy.array(self.param_subsets)
            self.subsets=set(list(param_subsets))


    def evaluate(self, cost, theta, c_k, gradient_reps=1):
#         assert len(theta)==len(self.)
        #If no subsets were defined, then now we'll define all model parameters as one set
        if self.param_subsets is None:
            self.param_subsets=numpy.zeros(theta.shape[0])
            self.subsets=set(list(self.param_subsets))
        #evaluate the gradient separately for different groups of parameters
        grad_list=[]
        for rep in range(gradient_reps):

            ghat=numpy.zeros(theta.shape)
            for s in self.subsets:
                param_filter=self.param_subsets==s
                ghat+=self.SPSA(cost, theta, c_k, param_filter)
            grad_list.append(ghat)
        if gradient_reps==1:
            return grad_list[0]
        else: #We need to average
            return numpy.mean(grad_list,0)

    def SPSA(self, cost, theta, ck, param_ind):
        """ Inputs:
            cost - a function that takes model parameters and data as inputs
                    and returns a single float
            data - the data the model is being fit to
            theta - a set model parameters
            ck - the step size to be used during perturbation of the model parameters

            Outputs:
            An estimate of the gradient
        """
        #Draw the perturbation

        delta=2*scipy.stats.bernoulli.rvs(p=.5,size=theta.shape[0])-1
        #hold delta constant for the parameters not under consideration
        delta[~param_ind]=0.
        #Perturb the parameters forwards and backwards
        thetaplus=theta+ck*delta
        thetaminus=theta-ck*delta

        #Evaluate the objective after the perturbations
        yplus=cost.evaluate(thetaplus)
        yminus=cost.evaluate(thetaminus)

        #Compute the slope across the perturbation

        ghat=(yplus-yminus)/(2*ck*delta)

        ghat[~param_ind]=0
        return ghat