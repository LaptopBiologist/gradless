# AUTOGENERATED! DO NOT EDIT! File to edit: 03_costs.ipynb (unless otherwise specified).

__all__ = ['CostFunctionBase', 'CustomCost', 'ELBO']

# Cell
import numpy
import scipy
import scipy.stats

from abc import ABC, abstractmethod

# Cell
class CostFunctionBase(ABC):

    @abstractmethod     #Require that all cost functions have the .evaluate method

    def evaluate(self): pass

    def sample_rvs(self):
        """This can be used to regenerate a random variable used by the cost function.
        It may be desirable hold some random variables constant during gradient evaluations, for example"""
        if self.RV is not None:
            self.z=self.RV.rvs()



# Cell
class CustomCost(CostFunctionBase):
    def __init__(self, cost, data, RV=None):
        self.cost=cost
        self.data=data
        self.RV=RV
        if self.RV is not None:
            self.z=self.sample_rvs()
    def evaluate(self, theta):
        if self.RV is None:
            return self.cost(theta, self.data)
        else:
            return self.cost(theta, self.data, self.z)

# Cell


class ELBO(CostFunctionBase):
    def __init__(self, evidence, data, param_num):
        self.cost=evidence
        self.data=data
        self.RV=scipy.stats.norm([0.]*param_num,[1.]*param_num)
        self.z=self.RV.rvs()
    def evaluate(self, theta):
        mu=theta[::2]
        sd=theta[1::2]

        eps=mu+self.z*(2.**sd)

        p=self.cost(eps, self.data)
        q=scipy.stats.norm.logpdf(eps, mu,2.**sd).sum()
        return -(p-q)
#     def up